# КРАТКОЕ ВВЕДЕНИЕ В ПРОЕКТ



## Что это?
Данный проект должен рассматриваться как __альтернатива тестовому заданию__. Он представляет собой небольшую **карточную игру**, созданную с использованием **Unity**.

![](/doc/images/game_screenshot_1.jpg)

*Важно!* Многие аспекты игры намеренно выполнены в упрощенном виде ввиду ограниченного количества времени, которое можно посвятить подобному проекту.

### Правила игры

- На старте все карты из колоды равномерно распределяются между игроками.
- __Задача игрока:__ как можно быстрее избавиться от имеющихся у него карт.
- Последний оставшийся с картами игрок считается __проигравшим__.
- __Избавится от карт можно лишь одним способом:__

  В любой момент времени игроку разрешается сбросить **2 карты**, если у них **совпадает значение** (например, **король червей** и **король крести**).

  Исключение лишь __пиковая дама__ - __*ее сбрасывать запрещено!*__

- Также игроки должны по очереди забирать у соседа слева по одной карте наугад (в надежде, что полученная карта образует с какой-либо из имеющихся пару).




## Как организован код?

### Unity - "оболочка" для запуска приложения.

Первое, на что стоит обратить внимание, это MonoBehaviour-скрипт _**EntryPoint**_, прикрепленный к одноименному объекту на главной (и единственной) сцене проекта.
Его задача - инициализировать и запустить основной код приложения из специальной библиотеки.

Основной код приложения, важно отметить, напрямую не обращается к Unity и от неё не зависит (используется паттерн **Inversion of Control**). Иными словами,
"движок", на котором работает игра, спрятан за абстракцией, что упрощает замену Unity на альтернативную платформу в случае необходимости.


### Компоненты приложения.

Основной код приложения представлен классом _**GameApp**_ (_реализует **IApp**_).

В текущей версии имеет следующие компоненты:
- _**IMainMenu**_

  **Главное меню** для общения с пользователем. С его помощью приложение узнает желания пользователя и исполняет их
  _(например, **начинает новую игру** или **завершает свою работу**)_.

- _**GameCore**_

  Непосредственно **игра**. Экземпляр класса создается и запускается, если пользователь выбрал начать новую игру.
  Главное меню при этом прячется до завершения игры.

_Примечание 1:_
Класс _**GameCore**_ это на самом деле адаптер, инкапсулирующий и запускающий экземпляр класса _**QosGame**_.

_Примечание 2:_
Класс _**GameCore**_ далее будет называться **игровым ядром приложения**.


### Компоненты игрового ядра приложения.

_**QosGame**_ состоит из двух частей:

- _**IGameWorld**_

  Так называемая "серверная" часть. Несет ответственность за все важнейшие вычисления и основную логику игры.

- _**IInteractor**_

  "Клиентская" часть, что зависит от "серверной". Должна отображать для пользователя все происходящее в игре в графическом (_или каком-либо ином виде_),
  а также обеспечить взаимодействие пользователя с игровым миром.

_**IGameWorld**_ и _**IInteractor**_ общаются при помощи игровых событий _**IEvent**_.

_**IGameWorld**_ генерирует игровые события (_например, событие **окончания матча** или событие **передачи карт от одного игрока другому**_),
а _**IInteractor**_ отслеживает их, чтобы соответствующим образом обновить "картинку" на экране.

Если _**IGameWorld**_ нуждается в обратной связи (_например, ему нужно узнать, какую карту из предложенных выбрал игрок_),
он прикрепляет к соответствующему игровому событию своеобразный callback (как правило, реализованный через класс _**BaseInteraction**_).
_**IInteractor**_ использует этот callback, чтобы оповестить "сервер" о выборе пользователя.


### Подробнее о "серверной" части.

_**IGameWorld**_ это абстракция, за которой потенциально может скрываться как локальный сервер, так и удаленный для многопользовательской игры
(_пока не реализовано_). Следующая схема демонстрирует взаимосвязь компонентов, прячущихся за интерфейсом _**IGameWorld**_.

![IGameWorld](/doc/images/local_server_scheme.jpg "Что спрятано за IGameWorld при локальной игре с двумя ботами.")

Класс _**GameWorld**_ самое сердце игровой логики. Внутри итерируется корутина (_примерно похожая на ту, что используется в MonoBehaviour-скриптах в Unity_),
которая и "ведет" матч, генерируя игровые события.


### Подробнее о "клиентской" части.

Интерфейс _**IInteractor**_ реализуется классом _**GraphicSceneInteractor**_, отображающим игровой мир при помощи трехмерной игровой сцены.

Его внутреннее устройство напоминает конвейер: определенным образом выстроенную очередь из объектов, реализующих _**IController**_
(_далее эти объекты будут называться **контроллерами**_).

Во время очередного обновления кадра (*на самом деле чаще*), у первого _**контроллера**_ вызывается метод **Update()**, он производит
некоторые операции или вычисления, передает результаты своей работы следующим в очереди контроллерам, и тот же самый процесс повторяется для них.
Таким образом в течении одного кадра поэтапно происходит процесс обновления игровой сцены.

- **Порядок контроллеров очень важен!**

Любой из контроллеров, как правило, опирается на результаты работы другого контроллера, потому зависимый контроллер **должен обновляться позднее своих зависимостей** (_цикличесские зависимости запрещены_).


![controllers_example](/doc/images/controllers_example.jpg "Значительно упрощенный граф контроллеров (очередь контроллеров выстраивается согласно этому графу).")



## Использованные материалы

- _Декорация:_

**Snowy Village** by **Falcon Tuden** (CC Attribution Licence)

(https://sketchfab.com/3d-models/snowy-village-c1351549159048a1a3ecdb84dedde48f)

- _Исходники для элементов UI:_

(https://www.freepik.com/free-vector/glossy-pink-boards-with-level-score-win-lose-banners-game-ui-interface-vector-cartoon-set-level-achievements-with-gold-stars-coins-buttons-isolated-background_24025530.htm)

- _Исходники для моделей персонажей:_

**Ultimate Monsters** by **Quaternius** (CC0 License)

(https://quaternius.com/packs/ultimatemonsters.html)